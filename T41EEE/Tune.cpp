
#include "SDT.h"

uint64_t Clk0SetFreq = 0;
uint64_t Clk1SetFreq = 0;
uint64_t Clk2SetFreq = 0;

#ifdef PLLMODULE
/*****
  Purpose: A special variant of SetFreq() used only for calibration.

  Parameter list:
    void

  Return value;
    void

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
void SetFreqCal(int calFreqShift) {  // July 7 2023 KF5N
uint32_t IFFreq = SR[SampleRate].rate / 4;  // IF (intermediate) frequency
  // NEVER USE AUDIONOINTERRUPTS HERE: that introduces annoying clicking noise with every frequency change
  // SI5351_FREQ_MULT is 100ULL, MASTER_CLK_MULT is 4;
  int cwFreqOffset = (EEPROMData.CWOffset + 6) * 24000 / 256;  // Calculate the CW offset based on user selected CW offset frequency.
  // The SSB LO frequency is always the same as the displayed transmit frequency.
  // The CW LOT frequency must be shifted by 750 Hz due to the way the CW carrier is generated by a quadrature tone.
  if (bands[EEPROMData.currentBand].mode == DEMOD_LSB)
    Clk2SetFreq = (((TxRxFreq + cwFreqOffset + calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 09-27-22;  KF5N flip CWFreqShift, sign originally minus
  if (bands[EEPROMData.currentBand].mode == DEMOD_USB)
    Clk2SetFreq = (((TxRxFreq - cwFreqOffset - calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 10-01-22; KF5N flip CWFreqShift, sign originally plus

  //  The receive LO frequency is not dependent on mode or sideband.  CW frequency shift is done in DSP code.
  Clk0SetFreq = ((EEPROMData.centerFreq * SI5351_FREQ_MULT) + IFFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_RX;

  //  Set and enable both RX and TX local oscillator outputs.
  si5351.set_freq(Clk0SetFreq, SI5351_CLK0);
  si5351.set_freq(Clk2SetFreq, SI5351_CLK2);
  si5351.output_enable(SI5351_CLK0, 1);
  si5351.output_enable(SI5351_CLK2, 1);
}


/*****
  Purpose: SetFrequency

  Parameter list:
    void

  Return value;
    void

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
void SetFreq() {  //AFP 09-22-22   Revised July 7 KF5N
uint32_t IFFreq = SR[SampleRate].rate / 4;  // IF (intermediate) frequency
  // NEVER USE AUDIONOINTERRUPTS HERE: that introduces annoying clicking noise with every frequency change
  // SI5351_FREQ_MULT is 100ULL, MASTER_CLK_MULT is 4;
  int cwFreqOffset = (EEPROMData.CWOffset + 6) * 24000 / 256;  // Calculate the CW offset based on user selected CW offset frequency.
  // The SSB LO frequency is always the same as the displayed transmit frequency.
  // The CW LOT frequency must be shifted by 750 Hz due to the way the CW carrier is generated by a quadrature tone.
  if (radioState == RadioState::SSB_TRANSMIT_STATE) {
    Clk2SetFreq = (TxRxFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_TX;  // AFP 09-27-22
  } else if (radioState == RadioState::CW_TRANSMIT_STRAIGHT_STATE || radioState == RadioState::CW_TRANSMIT_KEYER_STATE) {
    if (bands[EEPROMData.currentBand].mode == DEMOD_LSB) {
      Clk2SetFreq = (((TxRxFreq + cwFreqOffset) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 09-27-22;  KF5N flip CWFreqShift, sign originally minus
    } else {
      if (bands[EEPROMData.currentBand].mode == DEMOD_USB) {
        Clk2SetFreq = (((TxRxFreq - cwFreqOffset) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 10-01-22; KF5N flip CWFreqShift, sign originally plus
      }
    }
  }

  //  The receive LO frequency is not dependent on mode or sideband.  CW frequency shift is done in DSP code.
  Clk0SetFreq = ((EEPROMData.centerFreq * SI5351_FREQ_MULT) + IFFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_RX;

  if (radioState == RadioState::SSB_RECEIVE_STATE || radioState == RadioState::CW_RECEIVE_STATE || radioState == RadioState::AM_RECEIVE_STATE) {  //  Receive state
    si5351.set_freq(Clk0SetFreq, SI5351_CLK0);
    si5351.output_enable(SI5351_CLK2, 0);  // CLK2 (transmit) off during receive to prevent birdies
    si5351.output_enable(SI5351_CLK0, 1);
  }

  if (radioState == RadioState::SSB_TRANSMIT_STATE || radioState == RadioState::CW_TRANSMIT_STRAIGHT_STATE || radioState == RadioState::CW_TRANSMIT_KEYER_STATE) {  // Transmit state
    si5351.set_freq(Clk2SetFreq, SI5351_CLK2);
    si5351.output_enable(SI5351_CLK0, 0);  // CLK0 (receive) off during transmit to prevent spurious outputs
    si5351.output_enable(SI5351_CLK2, 1);
  }
  //=====================  AFP 10-03-22 =================
  DrawFrequencyBarValue();
}
#else // PLLMODULE
#ifdef HARDWARE_F1FGV

void SetFreqCal(int calFreqShift) {  // July 7 2023 KF5N
    Serial.printf("SetFreqCal with shift: %d\n", calFreqShift);
}


#define SERIAL_PRINT_LL(llnumber) Serial.print(llnumber)
 // siFrequency is in 1/100 of Hz
void SetFreqWithQuadrature(unsigned long long siFrequency){
  static uint16_t currentDivider;
  bool bMustChangeDivider;
  uint64_t pll_freq;

  Serial.print("si5351 requested frequency: ");
  SERIAL_PRINT_LL(siFrequency / SI5351_FREQ_MULT);
  // check if we have to change Divider
  bMustChangeDivider = (siFrequency * currentDivider / SI5351_FREQ_MULT > SI5351_PLL_VCO_MAX || siFrequency * currentDivider / SI5351_FREQ_MULT < SI5351_PLL_VCO_MIN);
  if (bMustChangeDivider){
    uint16_t divider;
    divider = 1 + (SI5351_PLL_VCO_MIN + SI5351_PLL_VCO_MAX)/2 * SI5351_FREQ_MULT / siFrequency; // center on pll band
    divider &=  0xFFFE; // make it even
    if (divider < 4)
      divider = 4;
    Serial.print(" previous divider: ");
    Serial.print(currentDivider);
    currentDivider = divider;
    Serial.print(" new divider: ");
    Serial.print(currentDivider);
  }
  pll_freq = siFrequency * currentDivider;
  
  Serial.print(" pll frequency: ");
  SERIAL_PRINT_LL(pll_freq / SI5351_FREQ_MULT);
  Serial.print(" divider: ");
  Serial.print(currentDivider);
  Serial.print(" remainder: ");
  SERIAL_PRINT_LL(pll_freq % siFrequency);
  Serial.println("");

  // use the manual interface
  // Set CLK0 and CLK1 to output using the computed PLL frequency
  si5351.set_freq_manual(siFrequency, pll_freq, SI5351_CLK0);
  si5351.set_freq_manual(siFrequency, pll_freq, SI5351_CLK1);
  // test tone
  si5351.set_freq_manual(siFrequency - 50000 * SI5351_FREQ_MULT, pll_freq, SI5351_CLK2); // set test generator with an offset

  if (1 || bMustChangeDivider){ // always reset PLL for now
    si5351.set_phase(SI5351_CLK0, 0);
    si5351.set_phase(SI5351_CLK1, 0);

    si5351.pll_reset(SI5351_PLLA);

    //cli(); // mask interrupts to get precise timing
    si5351.set_freq_manual(siFrequency, pll_freq, SI5351_CLK0);
    si5351.set_freq_manual(siFrequency - 1000, pll_freq, SI5351_CLK1); // 10Hz lower
    delay(20);
    //delayMicroseconds(21000); //  wait for the phase to become -90 degrees
    si5351.set_freq_manual(siFrequency, pll_freq, SI5351_CLK1);
    //sei();
  } else {
    si5351.set_freq_manual(siFrequency, pll_freq, SI5351_CLK0);
    si5351.set_freq_manual(siFrequency - 1000, pll_freq, SI5351_CLK1);
  }
}

void SetFreq() {  //AFP 09-22-22   Revised July 7 KF5N
uint32_t IFFreq = SR[SampleRate].rate / 4;  // IF (intermediate) frequency
  // NEVER USE AUDIONOINTERRUPTS HERE: that introduces annoying clicking noise with every frequency change
  // SI5351_FREQ_MULT is 100ULL, MASTER_CLK_MULT is 4;
  int cwFreqOffset = (EEPROMData.CWOffset + 6) * 24000 / 256;  // Calculate the CW offset based on user selected CW offset frequency.
  // The SSB LO frequency is always the same as the displayed transmit frequency.
  // The CW LOT frequency must be shifted by 750 Hz due to the way the CW carrier is generated by a quadrature tone.
  if (radioState == RadioState::SSB_TRANSMIT_STATE) {
    Clk1SetFreq = (TxRxFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_TX;  // AFP 09-27-22
  } else if (radioState == RadioState::CW_TRANSMIT_STRAIGHT_STATE || radioState == RadioState::CW_TRANSMIT_KEYER_STATE) {
    if (bands[EEPROMData.currentBand].mode == DEMOD_LSB) {
      Clk1SetFreq = (((TxRxFreq + cwFreqOffset) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 09-27-22;  KF5N flip CWFreqShift, sign originally minus
    } else {
      if (bands[EEPROMData.currentBand].mode == DEMOD_USB) {
        Clk1SetFreq = (((TxRxFreq - cwFreqOffset) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 10-01-22; KF5N flip CWFreqShift, sign originally plus
      }
    }
  }

  //  The receive LO frequency is not dependent on mode or sideband.  CW frequency shift is done in DSP code.
  Clk2SetFreq = ((EEPROMData.centerFreq * SI5351_FREQ_MULT) + IFFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_RX;

  if (radioState == RadioState::SSB_RECEIVE_STATE || radioState == RadioState::CW_RECEIVE_STATE || radioState == RadioState::AM_RECEIVE_STATE) {  //  Receive state
    SetFreqWithQuadrature(Clk2SetFreq);
    si5351.output_enable(SI5351_CLK0, 1);
    si5351.output_enable(SI5351_CLK1, 1);
    // test tone is disabled for normal operation
    si5351.output_enable(SI5351_CLK2, 0);
  }

  if (radioState == RadioState::SSB_TRANSMIT_STATE || radioState == RadioState::CW_TRANSMIT_STRAIGHT_STATE || radioState == RadioState::CW_TRANSMIT_KEYER_STATE) {  // Transmit state
    Serial.printf("SetFreq called in transmit state (not good !): %d\n", TxRxFreq);
    si5351.set_freq(Clk1SetFreq, SI5351_CLK1);
    si5351.output_enable(SI5351_CLK2, 0);  // CLK2 (receive) off during transmit to prevent spurious outputs
    si5351.output_enable(SI5351_CLK1, 1);
  }
  //=====================  AFP 10-03-22 =================
  DrawFrequencyBarValue();
  Serial.printf("Receive SetFreq = %llu kHz IF = %lu Hz\n", Clk2SetFreq/100000, IFFreq);
}


#else //end HARDWARE_F1FGV begin standard hardware
/*****
  Purpose: A special variant of SetFreq() used only for calibration.

  Parameter list:
    void

  Return value;
    void

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
void SetFreqCal(int calFreqShift) {  // July 7 2023 KF5N
uint32_t IFFreq = SR[SampleRate].rate / 4;  // IF (intermediate) frequency
  // NEVER USE AUDIONOINTERRUPTS HERE: that introduces annoying clicking noise with every frequency change
  // SI5351_FREQ_MULT is 100ULL, MASTER_CLK_MULT is 4;
  int cwFreqOffset = (EEPROMData.CWOffset + 6) * 24000 / 256;  // Calculate the CW offset based on user selected CW offset frequency.
  // The SSB LO frequency is always the same as the displayed transmit frequency.
  // The CW LOT frequency must be shifted by 750 Hz due to the way the CW carrier is generated by a quadrature tone.
  if (bands[EEPROMData.currentBand].mode == DEMOD_LSB)
    Clk1SetFreq = (((TxRxFreq + cwFreqOffset + calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 09-27-22;  KF5N flip CWFreqShift, sign originally minus
  if (bands[EEPROMData.currentBand].mode == DEMOD_USB)
    Clk1SetFreq = (((TxRxFreq - cwFreqOffset - calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 10-01-22; KF5N flip CWFreqShift, sign originally plus

  //  The receive LO frequency is not dependent on mode or sideband.  CW frequency shift is done in DSP code.
  Clk2SetFreq = ((EEPROMData.centerFreq * SI5351_FREQ_MULT) + IFFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_RX;

  //  Set and enable both RX and TX local oscillator outputs.
  si5351.set_freq(Clk2SetFreq, SI5351_CLK2);
  si5351.set_freq(Clk1SetFreq, SI5351_CLK1);
  si5351.output_enable(SI5351_CLK2, 1);
  si5351.output_enable(SI5351_CLK1, 1);
}

/*****
  Purpose: SetFrequency

  Parameter list:
    void

  Return value;
    void

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
void SetFreq() {  //AFP 09-22-22   Revised July 7 KF5N
uint32_t IFFreq = SR[SampleRate].rate / 4;  // IF (intermediate) frequency
  // NEVER USE AUDIONOINTERRUPTS HERE: that introduces annoying clicking noise with every frequency change
  // SI5351_FREQ_MULT is 100ULL, MASTER_CLK_MULT is 4;
  int cwFreqOffset = (EEPROMData.CWOffset + 6) * 24000 / 256;  // Calculate the CW offset based on user selected CW offset frequency.
  // The SSB LO frequency is always the same as the displayed transmit frequency.
  // The CW LOT frequency must be shifted by 750 Hz due to the way the CW carrier is generated by a quadrature tone.
  if (radioState == RadioState::SSB_TRANSMIT_STATE) {
    Clk1SetFreq = (TxRxFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_TX;  // AFP 09-27-22
  } else if (radioState == RadioState::CW_TRANSMIT_STRAIGHT_STATE || radioState == RadioState::CW_TRANSMIT_KEYER_STATE) {
    if (bands[EEPROMData.currentBand].mode == DEMOD_LSB) {
      Clk1SetFreq = (((TxRxFreq + cwFreqOffset) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 09-27-22;  KF5N flip CWFreqShift, sign originally minus
    } else {
      if (bands[EEPROMData.currentBand].mode == DEMOD_USB) {
        Clk1SetFreq = (((TxRxFreq - cwFreqOffset) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT_TX;  // AFP 10-01-22; KF5N flip CWFreqShift, sign originally plus
      }
    }
  }

  //  The receive LO frequency is not dependent on mode or sideband.  CW frequency shift is done in DSP code.
  Clk2SetFreq = ((EEPROMData.centerFreq * SI5351_FREQ_MULT) + IFFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT_RX;

  if (radioState == RadioState::SSB_RECEIVE_STATE || radioState == RadioState::CW_RECEIVE_STATE || radioState == RadioState::AM_RECEIVE_STATE) {  //  Receive state
    SetFreqWithQuadrature(Clk2SetFreq);
    si5351.output_enable(SI5351_CLK1, 1);
    si5351.output_enable(SI5351_CLK2, 1);
  }

  if (radioState == RadioState::SSB_TRANSMIT_STATE || radioState == RadioState::CW_TRANSMIT_STRAIGHT_STATE || radioState == RadioState::CW_TRANSMIT_KEYER_STATE) {  // Transmit state
    si5351.set_freq(Clk1SetFreq, SI5351_CLK1);
    si5351.output_enable(SI5351_CLK2, 0);  // CLK2 (receive) off during transmit to prevent spurious outputs
    si5351.output_enable(SI5351_CLK1, 1);
  }
  //=====================  AFP 10-03-22 =================
  DrawFrequencyBarValue();
  Serial.printf("Clk2SetFreq = %llu kHz IF = %lu Hz\n", Clk2SetFreq/100000, IFFreq);
}
#endif //F1FGV
#endif //PLLMODULE


/***** //AFP 10-11-22 all new
  Purpose:  Reset tuning to center

  Parameter list:
  void

  Return value;
  void
*****/
void ResetTuning() {
  currentFreq = EEPROMData.centerFreq + NCOFreq;  // currentFreqA changed to currentFreq.  KF5N August 7, 2023
  NCOFreq = 0L;
  EEPROMData.centerFreq = TxRxFreq = currentFreq;  //AFP 10-28-22  // currentFreqA changed to currentFreq.  KF5N August 7, 2023
  tft.writeTo(L2);                                 // Clear layer 2.  KF5N July 31, 2023
  tft.clearMemory();
  SetFreq();  // For new tuning scheme.  KF5N July 22, 2023
  DrawBandWidthIndicatorBar();
  BandInformation();
  ShowFrequency();
  UpdateDecoderField();  // Update Morse decoder if used.
  FilterSetSSB();
}


/*****
  Purpose: Places the Fast Tune cursor in the center of the spectrum display

  Parameter list:

  Return value;
    void
*****/
void CenterFastTune() {
  tft.drawFastVLine(oldCursorPosition, SPECTRUM_TOP_Y + 20, SPECTRUM_HEIGHT - 27, RA8875_BLACK);
  tft.drawFastVLine(newCursorPosition, SPECTRUM_TOP_Y + 20, SPECTRUM_HEIGHT - 27, RA8875_RED);
}


/*****
  Purpose: Purpose is to sety VFOa to receive frequency and VFOb to the transmit frequency

  Parameter list:
    void

  Return value;
    int           the offset as an int

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
int DoSplitVFO() {
  char freqBuffer[15];
//  int val;
  MenuSelect menu;
  long chunk = SPLIT_INCREMENT;
  long splitOffset;

  tft.drawRect(INFORMATION_WINDOW_X - 10, INFORMATION_WINDOW_Y - 2, 260, 200, RA8875_MAGENTA);
  tft.fillRect(INFORMATION_WINDOW_X - 8, INFORMATION_WINDOW_Y, 250, 185, RA8875_BLACK);  // Clear volume field
  tft.setFontScale((enum RA8875tsize)1);
  tft.setCursor(INFORMATION_WINDOW_X + 10, INFORMATION_WINDOW_Y + 5);
  tft.print("xmit offset: ");

  splitOffset = chunk;  // Set starting offset to 500Hz
  tft.setTextColor(RA8875_GREEN);
  tft.setCursor(INFORMATION_WINDOW_X + 60, INFORMATION_WINDOW_Y + 90);
  tft.print(splitOffset);
  tft.print("Hz  ");

  while (true) {
    if (filterEncoderMove != 0) {  // Changed encoder?
      splitOffset += filterEncoderMove * chunk;
      tft.fillRect(INFORMATION_WINDOW_X + 60, INFORMATION_WINDOW_Y + 90, 150, 50, RA8875_BLACK);
      tft.setCursor(INFORMATION_WINDOW_X + 60, INFORMATION_WINDOW_Y + 90);
      tft.print(splitOffset);
      tft.print("Hz  ");
    }
    filterEncoderMove = 0L;

//    val = ReadSelectedPushButton();  // Read pin that controls all switches
    menu = readButton();
//    delay(150L);
    if (menu == MenuSelect::MENU_OPTION_SELECT) {  // Make a choice??
      Clk1SetFreq += splitOffset;     // New transmit frequency // AFP 09-27-22
      UpdateInfoWindow();
      filterEncoderMove = 0L;
      break;
    }
  }
  EEPROMData.currentFreqB = EEPROMData.currentFreqA + splitOffset;
  FormatFrequency(EEPROMData.currentFreqB, freqBuffer);
  tft.fillRect(FREQUENCY_X_SPLIT, FREQUENCY_Y - 12, VFOB_PIXEL_LENGTH, FREQUENCY_PIXEL_HI, RA8875_BLACK);
  tft.setCursor(FREQUENCY_X_SPLIT, FREQUENCY_Y);
  tft.setFont(&FreeMonoBold24pt7b);
  tft.setTextColor(RA8875_GREEN);
  tft.print(freqBuffer);  // Show VFO_A

  tft.setFont(&FreeMonoBold18pt7b);
  FormatFrequency(EEPROMData.currentFreqA, freqBuffer);
  tft.setTextColor(RA8875_LIGHT_GREY);
  tft.setCursor(FREQUENCY_X, FREQUENCY_Y + 6);
  tft.print(freqBuffer);  // Show VFO_A

  tft.useLayers(1);  //mainly used to turn on layers!
  tft.layerEffect(OR);
  tft.writeTo(L2);
  tft.clearMemory();
  tft.writeTo(L1);

  tft.setFont(&FreeMono9pt7b);
  tft.setTextColor(RA8875_RED);
  tft.setCursor(FILTER_PARAMETERS_X + 180, FILTER_PARAMETERS_Y + 6);
  tft.print("Split Active");

  tft.setFontDefault();
  return (int)splitOffset;  // Can be +/-
}


/*****
  Purpose: Reset the flip-flops in the QSD2/QSE2 quadrature generators.

  Parameter list:
    void

  Return value;
    void
*****/
void ResetFlipFlops() {
#ifdef HARDWARE_F1FGV
  return;
#endif
  // Toggle GPO0 low momentarily to reset the divide-by-2 flop-flops.
  // GPO0 is held high during normal operation.
  si5351.output_enable(SI5351_CLK2, 0);
#ifdef PLLMODULE
  si5351.output_enable(SI5351_CLK0, 0);
#else
  si5351.output_enable(SI5351_CLK1, 0);
#endif
  digitalWrite(0, LOW);  // Reset low.
  delay(500);
  digitalWrite(0, HIGH);  // Normal operation high.
  delay(500);
}
